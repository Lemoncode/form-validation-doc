{"version":3,"sources":["webpack:///../validators/custom-validators-sync.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---validators-custom-validators-sync-mdx-5f1e5c696a3e1e759720.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/circleci/test-ci-code/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"custom-validators-synchronous\"\n    }}>{`Custom validators synchronous`}</h1>\n    <p>{`Once you have checked that a given field or record validation is not available in the base or\nthird parties list of validators, it's time to create your own validator.`}</p>\n    <h2 {...{\n      \"id\": \"field-validator\"\n    }}>{`Field Validator`}</h2>\n    <p>{`A field synchronous validator is just a function that expected one argument (this arugment is an object that contains\nseveral fields), and return a validation result.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`What do we mean by synchronous? That is any validation that executes some code and returns a straightforward result,\nif your validation needs to make a request to a server, it cannot provide a straightdforward result and probably\nyou will have to manage it using promises, that is an asynchronous validation and it's covered in the following\n`}<a parentName=\"p\" {...{\n          \"href\": \"/fonk-doc/validators/custom-validators-async\"\n        }}>{`link`}</a>{`.`}</p>\n    </blockquote>\n    <p>{`Usually a Field Validator can be a perfect piece of code to be reused across the application and even as a library.`}</p>\n    <h3 {...{\n      \"id\": \"disecting-a-validator\"\n    }}>{`Disecting a validator`}</h3>\n    <p>{`The definition of a synchronous field validator:`}</p>\n    <ul>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`FielValidationArgs`}</strong>{`: This is passed as a single argument in th validator`}<ul parentName=\"li\">\n          <li parentName=\"ul\"><strong parentName=\"li\">{`value`}</strong>{`: current field value.`}</li>\n          <li parentName=\"ul\"><strong parentName=\"li\">{`values`}</strong>{`: form / record values (all fields).`}</li>\n          <li parentName=\"ul\"><strong parentName=\"li\">{`customArgs`}</strong>{`: we can pass custom arguments to our validator, this allow us to create flexible and configurable\nvalidators (e.g. in a min-lenght validator we can pass as customArgument a number indicating the minlenght allowed,\nor if we have a password / repeat password validator we can pass the id of the password field to the repeat password\nfield).`}</li>\n          <li parentName=\"ul\"><strong parentName=\"li\">{`message`}</strong>{`: you can override here the error message that the validator returns in case of failure. You can inject\nin a message `}<em parentName=\"li\">{`parameters`}</em>{` to be interpolated by the validator (e.g. 'string must be at least {{minlength}}'),\nin some validators there may be more than one error message defined, in that case we can pass an array of strings.`}</li>\n        </ul></li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`ValidationResult`}</strong>{`: once the validator has been executed it returns a `}<em parentName=\"li\">{`ValidationResult`}</em>{`:`}<ul parentName=\"li\">\n          <li parentName=\"ul\">{`If the validation succeeds, you get as return value a `}<em parentName=\"li\">{`ValidationResult`}</em>{` where it's field `}<em parentName=\"li\">{`succeeded`}</em>{` is true.`}</li>\n          <li parentName=\"ul\">{`If the validation fails, you get as return value a `}<em parentName=\"li\">{`ValidationResult`}{`_`}{`_`}{` where it's field `}{`_`}{`succeeded`}</em>{` is false,\na `}<em parentName=\"li\">{`message`}</em>{` where you get the error message (user friendly) and a `}<em parentName=\"li\">{`type`}</em>{` field that indicates the validator that\nfailed.`}</li>\n        </ul></li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`export interface FieldValidatorArgs {\n  value: any;\n  values?: any;\n  customArgs?: any;\n  message?: string | string[];\n}\n\nexport interface ValidationResult {\n  type: string;\n  succeeded: boolean;\n  message: string;\n}\n\nexport type FieldValidationFunctionSync = (\n  fieldValidatorArgs: FieldValidatorArgs\n) => ValidationResult;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"learning-by-example\"\n    }}>{`Learning by example`}</h3>\n    <p>{`The best way to learn how to implementing a validator is just by doing it so.`}</p>\n    <p>{`Let's get started, we want to validate that an `}<a parentName=\"p\" {...{\n        \"href\": \"https://en.wikipedia.org/wiki/International_Bank_Account_Number\"\n      }}>{`IBAN`}</a>{`\n(International Bank Account) field belongs to Spain (that is first two characters are equal to `}<em parentName=\"p\">{`ES`}</em>{`).`}</p>\n    <p>{`We will start simple, in order to check we only need use the `}<em parentName=\"p\">{`value`}</em>{` we\ndon't need the rest of optional params: `}<em parentName=\"p\">{`values`}</em>{`, `}<em parentName=\"p\">{`customArgs`}</em>{`, `}<em parentName=\"p\">{`message`}</em>{`, we will follow a TDD like approach\nwe will create the validator always faling (returning a failed validation result).`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const validatorType = 'MY_IBAN_VALIDATOR';\n\nexport const myValidator = fieldValidatorArgs => {\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n    message: 'IBAN does not belong to Spain',\n  };\n\n  return validationResult;\n};\n`}</code></pre>\n    <p>{`Cool, we got a validator that always fails, now is time to inject our logic; we just want to validate\nthat the IBAN belongs to spain (first two characters must be `}<em parentName=\"p\">{`ES`}</em>{`).`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`const validatorType = 'MY_IBAN_VALIDATOR';\n\nexport const myValidator = fieldValidatorArgs => {\n+ const { value } = fieldValidatorArgs;\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n    message: 'IBAN does not belong to Spain',\n  };\n\n+ if (value && value[0] === 'E' && value[1] === 'S') {\n+   validationResult.succeeded = true;\n+   validationResult.message = '';\n+ }\n\n  return validationResult;\n}\n`}</code></pre>\n    <p>{`No we got our simple validator working, if you enter an IBAN that belongs to spain it will pass\nthe validation if not if will fail.`}</p>\n    <p><em parentName=\"p\">{`Watch out... what if we pass a null/undefined/empty string?`}</em>{` Validation will succeed in this case, `}<em parentName=\"p\">{`but is\nnot a valid IBAN isn't it?`}</em>{` Usually is a good practice to delegate this validation to a prior validator like\nthe built-in `}<strong parentName=\"p\">{`required`}</strong>{` validator, why: maybe the field you want to validate is optional hence the\nIBAN validator should not fail, by doing that we are following the single responsibility principle.`}</p>\n    <p>{`The validator was fine but what happens if we need to override the validation message? For instance you\nneed give support to multiple languages (english, spanish, french...), you can override the\nmessage(s) validators in two ways:`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`You can setup the validator message(s) globally for any ValidationSchema instance (for instance you\njust change from english to french language and you want that `}<em parentName=\"p\">{`MyValidator`}</em>{` shows the error message\nin french in all the application forms where it's being used).`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`You can override the validation message just for a given ValidationSchema (for instance if you use\nthe `}<em parentName=\"p\">{`pattern`}</em>{` (regex) validator you may want for an specific field in a validation schema to return\n`}<em parentName=\"p\">{`invalid credit card`}</em>{` and for other cases `}<em parentName=\"p\">{`invalid shield number`}</em>{`).`}</p>\n      </li>\n    </ul>\n    <p>{`Let's start by preparing our validator to change the message for all the instances:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`const validatorType = 'MY_IBAN_VALIDATOR';\n\n+ let defaultMessage = 'IBAN does not belong to Spain';\n+ export const setErrorMessage = message => (defaultMessage = message);\n\nexport const myValidator = fieldValidatorArgs => {\n  const { value } = fieldValidatorArgs;\n\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n-   message: 'IBAN does not belong to Spain',\n+   message: defaultMessage,\n  };\n\n  if (value && value[0] === 'E' && value[1] === 'S') {\n    validationResult.succeeded = true;\n    validationResult.message = '';\n  }\n\n  return validationResult;\n};\n`}</code></pre>\n    <p>{`Now let's go for the specific override:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`const validatorType = 'MY_IBAN_VALIDATOR';\n\nlet defaultMessage = 'IBAN does not belong to Spain';\nexport const setErrorMessage = message => (defaultMessage = message);\n\nexport const myValidator = fieldValidatorArgs => {\n- const { value } = fieldValidatorArgs;\n+ const { value, message = defaultMessage } = fieldValidatorArgs;\n\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n-   message: defaultMessage,\n+   message,\n  };\n\n  if (value && value[0] === 'E' && value[1] === 'S') {\n    validationResult.succeeded = true;\n    validationResult.message = '';\n  }\n\n  return validationResult;\n};\n\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you want to learn more about how to customize error message + internazionalization you can jump\nto the following `}<a parentName=\"p\" {...{\n          \"href\": \"/fonk-doc/messages/error-message\"\n        }}>{`section`}</a>{`.`}</p>\n    </blockquote>\n    <p><em parentName=\"p\">{`That was awesome, but I need to implement this same validator for countries like france, germany, and others, is there a way to make this validator more generic?`}</em>{`\nYes, we can make use of `}<em parentName=\"p\">{`customArgs`}</em>{` and pass the `}<em parentName=\"p\">{`country`}</em>{` prefix to validate (in a real case you could opt in to implement this inside the validator using a switch\nstatement but the goal of this example is to show you how to deal with `}<em parentName=\"p\">{`customArgs`}</em>{`).`}</p>\n    <p>{`We can assume the consumer of this validator will pass the country code in the `}<em parentName=\"p\">{`customArgs`}</em>{` something like:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`{\n  countryCode: 'ES',\n}\n`}</code></pre>\n    <p>{`Let's further enhance the validator:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`const validatorType = 'MY_IBAN_VALIDATOR';\n\nlet defaultMessage = 'IBAN does not belong to Spain';\nexport const setErrorMessage = message => (defaultMessage = message);\n\n+ const hasValidCountryCode = (value, customArgs) =>\n+   value &&\n+   value[0] === customArgs.countryCode[0] &&\n+   value[1] === customArgs.countryCode[1];\n\nexport const myValidator = fieldValidatorArgs => {\n- const { value, message = defaultMessage } = fieldValidatorArgs;\n+ const { value, customArgs, message = defaultMessage } = fieldValidatorArgs;\n\n+ // Depending in your case you may feed default values to customArgs or throw\n+ // an exception or a console.log error\n+ if (!customArgs.countryCode || customArgs.countryCode.length !== 2) {\n+   throw \\`\\${validatorType}: error you should inform customArgs countryCode prefix (2 characters length)\\`;\n+ }\n\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n    message,\n  };\n\n- if (value && value[0] === 'E' && value[1] === 'S') {\n+ if (hasValidCountryCode(value, customArgs)) {\n    validationResult.succeeded = true;\n    validationResult.message = '';\n  }\n\n  return validationResult;\n};\n\n`}</code></pre>\n    <p>{`That was great, but there's something going wrong, the validation error message still says:`}</p>\n    <p><em parentName=\"p\">{`'IBAN does not belong to Spain'`}</em></p>\n    <p>{`We could just go the easy way and change the validation message to:`}</p>\n    <p><em parentName=\"p\">{`'IBAN country code not valid'`}</em></p>\n    <p>{`But we want to use a more elegant solution, why not building a message like:`}</p>\n    <p><em parentName=\"p\">{`IBAN country code prefix must be {{countryCode}}`}</em></p>\n    <p>{`Let's implement this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`+ import { parseMessageWithCustomArgs } from '@lemoncode/fonk';\nconst validatorType = 'MY_IBAN_VALIDATOR';\n\n- let defaultMessage = 'IBAN does not belong to Spain';\n+ let defaultMessage = 'IBAN does not belong to {{countryCode}}';\nexport const setErrorMessage = message => (defaultMessage = message);\n...\n\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n-   message,\n+   message: parseMessageWithCustomArgs(message, customArgs),\n  };\n\n`}</code></pre>\n    <p><em parentName=\"p\">{`Wow ! That was awesome ! but how can I customize this message if I need internazionalization?`}</em>{` You can\noverride the message and just use the same interpolation sequence `}<em parentName=\"p\">{`{{countryCode}}`}</em>{` where applies.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note down: you have to document this in your validator so consumers of your validator are aware of this params.`}</p>\n    </blockquote>\n    <p>{`Check here:\nFull example vanilla js\nFull eample vanilla ts\nFull example react final form js\nFull example react final form ts`}</p>\n    <p><em parentName=\"p\">{`So far so good, but what happens if I need another form field value to execute my field validator?`}</em>{` Let's say for\ninstance I got a signUp form where the user has to enter his password, then reenter it in a different field\nto avoid him introducing any typo by mistake. That's a great use case, let's dig into that:`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`This validator is already available as a third party plugin, you can find it in the following `}<a parentName=\"p\" {...{\n          \"href\": \"TODO\"\n        }}>{`link`}</a>{`.`}</p>\n    </blockquote>\n    <p>{`We've got the following form:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const mySignupFormData = {\n  email: 'john.doe@mydomain.com'\n  password : '123',\n  repeatPassword: '124',\n}\n`}</code></pre>\n    <p>{`First we will implement a validator specific for that form, we will access `}<em parentName=\"p\">{`customArgs.values`}</em>{` field to get other form field value:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const validatorType = 'FIELDS_MATCH_VALIDATOR';\n\n let defaultMessage = 'Fields does not match';\n export const setErrorMessage = message => (defaultMessage = message);\n\nexport const fieldMatchValidator = (fieldValidatorArgs) {\n  // All form/record data is passed in the fielValidatorArgs.values field\n  const {value, values, message = defaultMessage} = fieldValidatorArgs\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n    message,\n  };\n\n  // Now we can acces the 'password' field from the values field\n  if (value === values.password) {\n    validationResult.succeeded = true;\n    validationResult.message = '';\n  }\n\n  return validationResult;\n}\n`}</code></pre>\n    <p><em parentName=\"p\">{`Fine, we managed to build to the validator, but is too tied up to the form, couldn't it be possible to create a reusable validator?`}</em>{`\nthe answer is yes if we combine togheter `}<em parentName=\"p\">{`fieldValidationArgs.values`}</em>{` and `}<em parentName=\"p\">{`fieldValidationArgs.customArgs`}</em>{` (in customArgs we will\npass the name of the field to compare with).`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\"><strong parentName=\"p\">{`customArgs`}</strong>{`: here we will pass the id of the field to check (in this case the `}<em parentName=\"p\">{`password`}</em>{` field).`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\"><strong parentName=\"p\">{`values`}</strong>{`: here we get all the form/record values, we can use the following approach to access\nthe `}<em parentName=\"p\">{`password`}</em>{` field: `}{`_`}{`_`}</p>\n      </li>\n    </ul>\n    <p>{`Let's see how to combine this both together:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`const validatorType = 'FIELDS_MATCH_VALIDATOR';\n\n let defaultMessage = 'Fields does not match';\n export const setErrorMessage = message => (defaultMessage = message);\n\nexport const fieldMatchValidator = (fieldValidatorArgs) {\n  // All form/record data is passed in the fielValidatorArgs.values field\n+ // We will make use of customArgs\n-  const {value, values, message = defaultMessage} = fieldValidatorArgs\n+   const {value, values, customArgs, message = defaultMessage} = fieldValidatorArgs\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n    message,\n  };\n\n+  // Depending in your case you may feed default values to customArgs or throw\n+  // an exception or a console.log error\n+  if(!customArgs.fieldToCompareName) {\n+    throw(\\`\\${validatorType}: you need to inform the fieldToCompareName\\`)\n+  }\n\n-  // Now we can acces the 'password' field from the values field\n+  We just grab the value of the field using the bracke accesor\n+  more info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors\n-  if (value === values.password) {\n+  if(value === value[customArgs.fieldToCompareName])\n    validationResult.succeeded = true;\n    validationResult.message = '';\n  }\n\n  return validationResult;\n}\n`}</code></pre>\n    <p>{`Check here:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/docs/validators/js/vanilla/iban-custom-sync-validator\"\n        }}>{`Plain Vanilla JS`}</a>{`.`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/docs/validators/ts/vanilla/iban-custom-sync-validator\"\n        }}>{`Plain Vanilla TS`}</a>{`.`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/docs/validators/js/react-final-form/iban-custom-sync-validator\"\n        }}>{`React + React Final Form JS`}</a>{`.`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/docs/validators/ts/react-final-form/iban-custom-sync-validator\"\n        }}>{`React + React Final Form TS`}</a>{`.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"record-validator\"\n    }}>{`Record Validator`}</h2>\n    <p>{`A record validator is a validation that is not tied up to an specific field, is usually something that we trigger\nwhen the user hits submit, and previous to send the information to the server.`}</p>\n    <p>{`Record validations usually are not highly reusable functions, they are tied up to the domain of the form to be evaluated.`}</p>\n    <h3 {...{\n      \"id\": \"disecting-a-record-validator\"\n    }}>{`Disecting a record validator`}</h3>\n    <p>{`The definition of a synchronous field validator:`}</p>\n    <ul>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`RecordValidationArgs`}</strong>{`: This is passed as a single argument in the validator`}<ul parentName=\"li\">\n          <li parentName=\"ul\"><strong parentName=\"li\">{`values`}</strong>{`: form / record values (all fields).`}</li>\n          <li parentName=\"ul\"><strong parentName=\"li\">{`message`}</strong>{`: you can override here the error message that the validator returns in case of failure. You can inject\nin a message `}<em parentName=\"li\">{`parameters`}</em>{` to be interpolated by the validator (e.g. 'string must be at least {{minlength}}'),\nin some validators there may be more than one error message defined, in that case we can pass an array of strings.`}</li>\n        </ul></li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`ValidationResult`}</strong>{`: once the validator has been executed it returns a `}<em parentName=\"li\">{`ValidationResult`}</em>{`:`}<ul parentName=\"li\">\n          <li parentName=\"ul\">{`If the validation succeeds, you get as return value a `}<em parentName=\"li\">{`ValidationResult`}</em>{` where it's field `}<em parentName=\"li\">{`succeeded`}</em>{` is true.`}</li>\n          <li parentName=\"ul\">{`If the validation fails, you get as return value a `}<em parentName=\"li\">{`ValidationResult`}{`_`}{`_`}{` where it's field `}{`_`}{`succeeded`}</em>{` is false,\na `}<em parentName=\"li\">{`message`}</em>{` where you get the error message (user friendly) and a `}<em parentName=\"li\">{`type`}</em>{` field that indicates the validator that\nfailed.`}</li>\n        </ul></li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`export interface RecordValidatorArgs {\n  values: any;\n  message?: string | string[];\n}\n\nexport interface ValidationResult {\n  type: string;\n  succeeded: boolean;\n  message: string;\n}\n\nexport type RecordValidationFunctionSync = (\n  recordValidatorArgs: RecordValidatorArgs\n) => ValidationResult;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"learning-by-example-1\"\n    }}>{`Learning by example`}</h3>\n    <p>{`We got a form that displays the total of a given shopping order:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const myFormValues = {\n  product: 'shoes',\n  discount: 5,\n  price: 20,\n  isPrime: false,\n};\n`}</code></pre>\n    <p>{`Once the user hits on submit order and before sending the request to the server we want to check the following rule:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`FreeShipping can be true if the total amount (price - discount) is greater than 20 USD, or if the fied `}<em parentName=\"li\">{`isPrime`}</em>{` is true. We want to trigger\nthis validation when the user hits on submit.`}</li>\n    </ul>\n    <p>{`We only want to trigger this once the user has finished picking up the product he wants to buy (we don't want to annoy him meanwhile he is in the\nshopping cart process).`}</p>\n    <p>{`A validator to implement this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// A record validator receives in the args an object with\n// all the record values and optionally the custom message\nconst freeShippingRecordValidator = ({ values }) => {\n  const succeeded = values.isPrime || values.price - values.discount > 20;\n\n  return {\n    succeeded,\n    message: succeeded\n      ? ''\n      : 'Subscribe to prime service or total must be greater than 20USD',\n    type: 'RECORD_FREE_SHIPPING',\n  };\n};\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you need to implement internazionalization or customize messages you can follow the same approach\nas the described for the field record validations.`}</p>\n    </blockquote>\n    <p>{`Check here:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/vanilla/js/validate-record\"\n        }}>{`Plain Vanilla JS`}</a>{`.`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/vanilla/ts/validate-record\"\n        }}>{`Plain Vanilla TS`}</a>{`.`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/react-final-form/js/validate-record\"\n        }}>{`React + React Final Form JS`}</a>{`.`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/react-final-form/ts/validate-record\"\n        }}>{`React + React Final Form TS`}</a>{`.`}</li>\n    </ul>\n    <h1 {...{\n      \"id\": \"next-section\"\n    }}>{`Next section`}</h1>\n    <p>{`Now that you have learn how to build synchronous custom validators is time to learn how to implement `}<a parentName=\"p\" {...{\n        \"href\": \"/fonk-doc/validators/custom-validators-async\"\n      }}>{`asynchronous custom validators`}</a>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}